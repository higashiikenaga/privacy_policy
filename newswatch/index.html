<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1920, height=1080, initial-scale=1.0">
    <title>ニュース・防災情報リアルタイム配信</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        html, body, * { box-sizing: border-box; }
        html, body { width: 1920px; height: 1080px; margin: 0; padding: 0; overflow: hidden; background-color: transparent; font-family: 'Inter', sans-serif; color: #FFFFFF; }
        #pageBackground { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-color: transparent; transition: background-color 0.5s ease-in-out; }

        /* Top Bar for Clock and Weather */
        #topBar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5rem; /* Height of the top bar */
            background-color: #FFFFFF; /* 白背景に変更 */
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            z-index: 1001;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #topBar .clock-display, #topBar .weather-display {
            font-size: 2.2rem;
            font-weight: 700;
            /* 時計部分の背景と文字色を白背景に黒文字に変更 */
            background-color: #FFFFFF; /* 白背景 */
            color: #000000; /* 黒文字 */
            padding: 0.25rem 0.75rem; /* 適度なパディングを追加 */
            border-radius: 0.5rem; /* 角丸を追加 */
            text-shadow: none; /* テキストシャドウを削除 */
            flex-shrink: 0;
        }
        #topBar .clock-seconds { font-size: 1.3rem; vertical-align: middle; }

        /* New General News Ticker below Top Bar */
        #generalNewsTicker {
            position: fixed;
            top: 5rem; /* Below topBar */
            left: 0;
            width: 100%;
            height: 3rem; /* Small height for the ticker */
            background-color: rgba(0, 50, 100, 0.9); /* Slightly different dark blue */
            overflow: hidden;
            white-space: nowrap;
            z-index: 1001;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
        }
        #generalNewsContent {
            display: inline-block;
            font-size: 1.5rem; /* Smaller font size */
            font-weight: 600;
            color: #FFFFFF; /* White text */
            animation: generalNewsScroll linear infinite;
        }
        @keyframes generalNewsScroll {
            from { transform: translateX(100vw); } /* ビューポートの右端から開始 */
            to { transform: translateX(-100%); } /* 自身の幅分左に移動 */
        }

        /* Main Content Area adjusted */
        #mainContentArea {
            position: absolute;
            top: 10rem; /* 8remから10remに調整して下に移動 */
            left: 0;
            width: 100%;
            height: calc(100% - 10rem); /* Remaining height */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* News Box (main content when no tsunami) */
        .news-box {
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(173, 216, 230, 0.8) 0%, rgba(240, 240, 240, 0.8) 100%);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 4rem 6rem; /* Padding for content */
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            opacity: 1; /* Start visible */
            visibility: visible;
        }
        .news-box.active {
            opacity: 1;
            visibility: visible;
        }
        .news-box:not(.active) {
            opacity: 0;
            visibility: hidden;
            position: absolute; /* Take out of flow when hidden */
        }
        .news-content-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* Changed to column for header/title/description */
            justify-content: center;
            align-items: center;
            text-align: center; /* Center text */
        }
        .news-header {
            margin-bottom: 1rem;
        }
        .news-category {
            font-size: 1.8rem;
            font-weight: 700;
            color: #000080;
        }
        .news-title {
            font-size: 3.5rem;
            font-weight: 700;
            color: #000000;
            line-height: 1.2;
        }
        .news-description-main { /* Renamed to avoid conflict */
            font-size: 2.5rem;
            color: #333333;
            line-height: 1.5;
            max-height: 50%;
            overflow: hidden;
            margin-top: 1rem;
        }


        /* Ticker (bottom disaster ticker) */
        .ticker-container { 
            position: fixed; 
            bottom: 0; 
            left: 0; 
            width: 100%; 
            background-color: rgba(0, 0, 80, 0.9); 
            padding: 0.75rem 0; 
            overflow: hidden; 
            white-space: nowrap; 
            z-index: 10000; 
            display: flex; /* Always display flex */
            align-items: center;
            /* transformとtransition関連のスタイルを削除 */
        }
        /* .ticker-container.active のルールを削除 */
        .ticker-content { display: inline-block; font-size: 1.75rem; font-weight: 600; color: #FFD700; animation: tickerScroll linear infinite; }
        @keyframes tickerScroll { from { transform: translateX(100vw); } to { transform: translateX(-100%); } }

        /* Tsunami Info */
        .tsunami-evacuate-warning { 
            position: fixed; 
            top: 6rem; /* 5.5remから6remに調整 */
            left: 30px; 
            transform: translateX(0); 
            font-size: 3.5rem; 
            font-weight: 900; 
            color: white; 
            background-color: rgba(255, 0, 0, 0.8); 
            padding: 0.5rem 1.5rem; 
            border-radius: 1rem; 
            z-index: 1003; 
            display: none; 
        }
        .tsunami-evacuate-warning.active { display: block; }

        #tsunamiInfoContainer {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 80, 0.9); /* Dark background for tsunami info */
            backdrop-filter: blur(10px);
            z-index: 1002;
            color: white;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            transition: all 0.5s ease-in-out;
            opacity: 0; /* Start hidden */
            visibility: hidden;
            position: absolute; /* Take out of flow when hidden */
            left: 0;
        }
        #tsunamiInfoContainer.active {
            opacity: 1;
            visibility: visible;
        }
        #tsunamiInfoContainer:not(.active) {
            opacity: 0;
            visibility: hidden;
            position: absolute; /* Take out of flow when hidden */
        }
        .tsunami-info-header { font-size: 2.2rem; font-weight: 700; text-align: center; margin-bottom: 1rem; color: #FFD700; flex-shrink: 0; }
        .tsunami-content-wrapper { display: flex; flex-grow: 1; gap: 1rem; overflow: hidden; }
        #tsunamiObservationContainer, #tsunamiForecastContainer { display: none; flex-direction: column; }
        #tsunamiObservationContainer.active, #tsunamiForecastContainer.active { display: flex; }
        #tsunamiForecastContainer { flex-grow: 1; }
        .tsunami-table-wrapper { overflow: hidden; flex-grow: 1; position: relative; }
        .tsunami-table { width: 100%; border-collapse: collapse; font-size: 1.3rem; }
        .tsunami-table th, .tsunami-table td { border: 1px solid rgba(255, 255, 255, 0.3); padding: 0.5rem; text-align: left; }
        .tsunami-table th { background-color: rgba(255, 255, 255, 0.1); font-weight: 600; position: sticky; top: 0; }
        .tsunami-table .kind-major-warning, .tsunami-table .condition-high { color: #FF00FF; font-weight: bold; }
        .tsunami-table .kind-warning { color: #FF4500; font-weight: bold; }
        .tsunami-table .kind-advisory { color: #FFFF00; font-weight: bold; }
        .tsunami-table .condition-rise { color: #00BFFF; }
        .tsunami-pagination-dots { 
            position: absolute; 
            bottom: 5px; /* テーブルの下に配置 */
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            gap: 0.5rem; 
            padding-top: 0.5rem; /* ドットとテーブルの間に少しスペース */
        }
        .tsunami-pagination-dots .dot { width: 10px; height: 10px; background-color: rgba(255,255,255,0.5); border-radius: 50%; transition: background-color 0.3s; }
        .tsunami-pagination-dots .dot.active { background-color: white; }

        /* Tsunami Layout Active - Adjust for new column layout */
        body.tsunami-layout-active #mainContentArea {
            flex-direction: row; /* Allow side-by-side for observation/forecast */
        }
        body.tsunami-layout-active #tsunamiInfoContainer {
            width: 100%;
            height: 100%;
            padding-top: 1rem; /* Adjust padding for full screen */
            padding-bottom: 4rem;
        }
        body.tsunami-layout-active.observation-active #tsunamiObservationContainer { width: 40%; }
        body.tsunami-layout-active.observation-active #tsunamiForecastContainer { width: 60%; }

        /* When mini-news is active, adjust tsunamiInfoContainer width */
        body.tsunami-layout-active.mini-news-active #tsunamiInfoContainer {
            width: 70%; /* miniNewsDisplayの幅(30%)を引いた残りの幅 */
        }


        /* Tsunami Warning Level Backgrounds */
        body.tsunami-advisory #pageBackground { background-color: rgba(255, 223, 0, 0.7); }
        body.tsunami-warning #pageBackground { background-color: rgba(255, 69, 0, 0.7); }
        body.tsunami-major-warning #pageBackground { background-color: rgba(148, 0, 211, 0.7); }

        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: white; font-size: 2rem; z-index: 9999; background-color: rgba(0, 0, 0, 0.9); }

        /* Mini News Display */
        #miniNewsDisplay {
            position: fixed;
            top: 8.5rem; /* topBar (5rem) + generalNewsTicker (3rem) + 0.5rem (gap) */
            right: 0;
            width: 30%; /* 画面右側の幅を30%に縮小 */
            height: calc(100% - 8.5rem - 4rem); /* topからの位置とbottom ticker (4rem) を考慮 */
            background-color: rgba(255, 255, 255, 0.9); /* 半透明の白背景 */
            color: #000000; /* 黒文字 */
            padding: 1rem;
            border-bottom-left-radius: 1rem; /* 左下を角丸に */
            box-shadow: -5px 5px 15px rgba(0,0,0,0.3);
            z-index: 1002; /* 他のコンテンツの上に表示 */
            display: none; /* 初期状態は非表示 */
            overflow: hidden; /* はみ出したテキストは非表示 */
            flex-direction: column; /* コンテンツの縦方向配置 */
            justify-content: flex-start;
            align-items: flex-start;
            text-align: left;
        }
        #miniNewsDisplay.active {
            display: flex; /* アクティブ時に表示 */
        }
        .mini-news-category {
            font-size: 0.9rem; /* さらに小さく */
            font-weight: 700;
            color: #000080;
            margin-bottom: 0.2rem;
        }
        .mini-news-title {
            font-size: 1.2rem; /* さらに小さく */
            font-weight: 700;
            color: #000000;
            line-height: 1.2;
            margin-bottom: 0.5rem;
        }
        .mini-news-description {
            font-size: 0.9rem; /* さらに小さく */
            color: #333333;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis; /* はみ出したテキストを...で表示 */
            display: -webkit-box;
            -webkit-line-clamp: 6; /* 6行に制限 */
            -webkit-box-orient: vertical;
        }

        /* Tsunami Map Container */
        #tsunamiMapContainer {
            position: fixed; /* Fixed position relative to viewport */
            bottom: 2rem; /* 画面下から2rem */
            right: 2rem; /* 画面右から2rem */
            width: 600px; /* 固定幅 */
            height: 400px; /* 固定高さ */
            display: none; /* 初期状態は非表示に変更 */
            justify-content: center;
            align-items: center;
            z-index: 10000; /* 最前面に表示 */
            background-color: transparent; /* 背景は透明に */
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            border-radius: 1rem; /* 親コンテナにも角丸を適用 */
            overflow: hidden; /* 子要素がはみ出さないように */
        }
        #tsunamiMapContainer.active {
            display: flex; /* アクティブ時に表示 */
            opacity: 1;
            visibility: visible;
        }
        #tsunamiMap {
            width: 100%; /* 親コンテナの幅に合わせる */
            height: 100%; /* 親コンテナの高さに合わせる */
            background-color: rgba(0, 0, 100, 0.7); /* 地図の背景色 */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 1rem; /* Leafletマップにも角丸を適用 */
        }
        /* Custom tooltip styling for Leaflet */
        .leaflet-tooltip.map-tooltip {
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark background */
            color: white;
            border: none;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-size: 0.7rem; /* Smaller font size for tooltips */
            padding: 2px 5px; /* Smaller padding */
            white-space: nowrap; /* Prevent text wrapping */
            pointer-events: none; /* Allow clicks through to the map */
        }
        .leaflet-tooltip-bottom:before,
        .leaflet-tooltip-top:before,
        .leaflet-tooltip-left:before,
        .leaflet-tooltip-right:before {
            border: none; /* Remove the pointer triangle if desired, or style it */
        }

        .map-legend {
            position: absolute;
            bottom: 1rem; /* マップのCanvasの底から1rem */
            left: 1rem; /* マップのCanvasの左から1rem */
            background-color: rgba(255, 255, 255, 0.8);
            padding: 0.5rem 0.8rem; /* パディングを少し小さく */
            border-radius: 0.5rem;
            color: #000;
            font-size: 1rem; /* フォントサイズを小さく */
            font-weight: 600;
            display: flex;
            flex-direction: column;
            gap: 0.3rem; /* ギャップを小さく */
            z-index: 1001; /* マップの上に表示 */
        }
        .map-legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem; /* ギャップを小さく */
        }
        .map-legend-color {
            width: 15px; /* サイズを小さく */
            height: 15px; /* サイズを小さく */
            border-radius: 50%;
        }
        /* Updated legend colors based on tsunami height */
        /* #FF0000: Red, #FF8C00: DarkOrange, #FFFF00: Yellow, #32CD32: LimeGreen, #00BFFF: LightBlue, #8B008B: DarkMagenta, #808080: Grey */
        .map-legend .height-3plus { background-color: #FF0000; } /* 3.0m以上 */
        .map-legend .height-1to3 { background-color: #FF8C00; } /* 1.0m〜3.0m未満 */
        .map-legend .height-05to1 { background-color: #FFFF00; } /* 0.5m〜1.0m未満 */
        .map-legend .height-02to05 { background-color: #32CD32; } /* 0.2m〜0.5m未満 */
        .map-legend .height-less02 { background-color: #00BFFF; } /* 0.2m未満 */
        .map-legend .height-high-gigantic { background-color: #8B008B; } /* 「高い」「巨大」 */
        .map-legend .height-unknown { background-color: #808080; } /* 不明・観測中など */


        /* Map Region Display */
        #mapRegionDisplay {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 1.2rem;
            font-weight: 600;
            z-index: 1001;
            pointer-events: none; /* Allow clicks through to the map */
            display: none; /* 初期状態は非表示 */
        }

    </style>
</head>
<body>
    <div id="pageBackground"></div>

    <div id="topBar">
        <div id="currentClock" class="clock-display"></div>
        <div id="weatherForecast" class="weather-display"></div>
    </div>

    <!-- New General News Ticker -->
    <div id="generalNewsTicker" class="general-news-ticker">
        <div id="generalNewsContent" class="general-news-content"></div>
    </div>

    <div id="mainContentArea">
        <div id="newsBox" class="news-box active">
            <div id="newsContentWrapper" class="news-content-wrapper">
                <div class="news-header">
                    <div id="newsCategory" class="news-category"></div>
                    <div id="newsTitle" class="news-title"></div>
                </div>
                <div id="newsDescriptionMain" class="news-description-main"></div>
            </div>
        </div>

        <div id="tsunamiInfoContainer" class="tsunami-info-container">
            <div id="tsunamiInfoHeader" class="tsunami-info-header"></div>
            <div class="tsunami-content-wrapper">
                <div id="tsunamiObservationContainer">
                    <h3 class="tsunami-info-header" style="font-size: 1.8rem; margin-bottom: 0.5rem;">津波の観測状況</h3>
                    <div class="tsunami-table-wrapper">
                        <table class="tsunami-table">
                            <thead><tr><th>観測点</th><th>到達時刻</th><th>津波の高さ</th></tr></thead>
                            <tbody id="tsunamiObservationBody"></tbody>
                        </table>
                        <div id="tsunamiObservationPagination" class="tsunami-pagination-dots"></div> <!-- 観測データ用ページネーション -->
                    </div>
                </div>
                <div id="tsunamiForecastContainer">
                     <h3 id="tsunamiForecastHeader" class="tsunami-info-header" style="font-size: 1.8rem; margin-bottom: 0.5rem;">津波予報</h3>
                    <div class="tsunami-table-wrapper">
                        <table class="tsunami-table">
                            <thead><tr><th>地域</th><th>種類</th><th>到達予想</th><th>高さ</th></tr></thead>
                            <tbody id="tsunamiForecastBody"></tbody>
                        </table>
                        <div id="tsunamiForecastPagination" class="tsunami-pagination-dots"></div> <!-- 予報データ用ページネーション -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mini News Display (右上の小さいニュース表示) -->
    <div id="miniNewsDisplay" class="mini-news-display">
        <div id="miniNewsCategory" class="mini-news-category"></div>
        <div id="miniNewsTitle" class="mini-news-title"></div>
        <div id="miniNewsDescription" class="mini-news-description"></div>
    </div>

    <div id="tsunamiEvacuateWarning" class="tsunami-evacuate-warning">つなみ 避難！</div>
    <div id="tickerContainer" class="ticker-container">
        <div id="tickerContent" class="ticker-content"></div>
    </div>
    <div id="loadingOverlay" class="loading-overlay"><p>情報を取得中...</p></div>
    <audio id="bgmAudio" src="news2_F.mp3" loop autoplay></audio>

    <!-- Tsunami Map Container and Div -->
    <div id="tsunamiMapContainer">
        <div id="tsunamiMap"></div> <!-- Changed from canvas to div -->
        <div class="map-legend">
            <div class="map-legend-item"><span class="map-legend-color height-3plus"></span>3.0m以上</div>
            <div class="map-legend-item"><span class="map-legend-color height-1to3"></span>1.0m〜3.0m未満</div>
            <div class="map-legend-item"><span class="map-legend-color height-05to1"></span>0.5m〜1.0m未満</div>
            <div class="map-legend-item"><span class="map-legend-color height-02to05"></span>0.2m〜0.5m未満</div>
            <div class="map-legend-item"><span class="map-legend-color height-less02"></span>0.2m未満</div>
            <div class="map-legend-item"><span class="map-legend-color height-high-gigantic"></span>「高い」「巨大」</div>
            <div class="map-legend-item"><span class="map-legend-color height-unknown"></span>不明・観測中など</div>
        </div>
        <div id="mapRegionDisplay" class="map-region-display"></div> <!-- 地域名表示用 -->
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Custom JavaScript (moved after Leaflet JS) -->
    <script>
        const dom = {
            body: document.body,
            pageBackground: document.getElementById('pageBackground'),
            topBar: document.getElementById('topBar'),
            generalNewsTicker: document.getElementById('generalNewsTicker'),
            generalNewsContent: document.getElementById('generalNewsContent'),
            mainContentArea: document.getElementById('mainContentArea'),
            tsunamiInfoContainer: document.getElementById('tsunamiInfoContainer'),
            tsunamiInfoHeader: document.getElementById('tsunamiInfoHeader'),
            tsunamiObservationContainer: document.getElementById('tsunamiObservationContainer'),
            tsunamiObservationBody: document.getElementById('tsunamiObservationBody'),
            tsunamiObservationPagination: document.getElementById('tsunamiObservationPagination'),
            tsunamiForecastContainer: document.getElementById('tsunamiForecastContainer'),
            tsunamiForecastBody: document.getElementById('tsunamiForecastBody'),
            tsunamiForecastPagination: document.getElementById('tsunamiForecastPagination'),
            tsunamiEvacuateWarning: document.getElementById('tsunamiEvacuateWarning'),
            newsBox: document.getElementById('newsBox'),
            newsCategory: document.getElementById('newsCategory'),
            newsTitle: document.getElementById('newsTitle'),
            newsDescriptionMain: document.getElementById('newsDescriptionMain'),
            miniNewsDisplay: document.getElementById('miniNewsDisplay'),
            miniNewsCategory: document.getElementById('miniNewsCategory'),
            miniNewsTitle: document.getElementById('miniNewsTitle'),
            miniNewsDescription: document.getElementById('miniNewsDescription'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            tickerContainer: document.getElementById('tickerContainer'),
            tickerContent: document.getElementById('tickerContent'),
            currentClock: document.getElementById('currentClock'),
            weatherForecast: document.getElementById('weatherForecast'),
            bgmAudio: document.getElementById('bgmAudio'),
            tsunamiMapContainer: document.getElementById('tsunamiMapContainer'),
            tsunamiMapDiv: document.getElementById('tsunamiMap'), // Changed to div
            mapRegionDisplay: document.getElementById('mapRegionDisplay') // 地域名表示用要素
        };

        // Leaflet map instance
        let map;
        let currentTsunamiMarkers = L.layerGroup(); // Layer group for tsunami markers

        let newsItems = [], tickerItems = [], fetchedWeatherData = [], allTsunamiForecasts = [], allTsunamiObservations = [];
        let currentItemIndex = 0, currentWeatherIndex = 0;
        let currentTsunamiForecastPage = 0;
        let currentTsunamiObservationPage = 0;
        let isTsunamiActive = false;
        
        let slideshowInterval, weatherInterval, tsunamiInterval, tsunamiForecastPageInterval, tsunamiObservationPageInterval, generalNewsTickerAnimationInterval, tickerAnimationInterval, mapRegionCyclingInterval;

        const ITEMS_PER_PAGE = 10;

        // 地図上の主要な地域/観測点の緯度経度 (Leafletマーカー配置のため)
        const mapLocations = {
            '札幌': { lat: 43.06, lon: 141.35 },
            '仙台': { lat: 38.27, lon: 140.87 },
            '東京': { lat: 35.69, lon: 139.69 },
            '名古屋': { lat: 35.18, lon: 136.91 },
            '大阪': { lat: 34.69, lon: 135.50 },
            '広島': { lat: 34.39, lon: 132.46 },
            '博多': { lat: 33.59, lon: 130.40 },
            '那覇': { lat: 26.21, lon: 127.68 },
            '宮城金華山沖': { lat: 38.2, lon: 141.7 },
            '種子島': { lat: 30.43, lon: 130.98 },
            '奄美群島': { lat: 28.3, lon: 129.5 },
            '沖縄本島地方': { lat: 26.5, lon: 128.0 },
            '宮古島・八重山地方': { lat: 24.7, lon: 125.0 },
            '大分県南部・内海沿岸': { lat: 32.8, lon: 131.7 },
            '大分県豊後水道沿岸': { lat: 33.1, lon: 132.2 },
            '鹿児島県東部': { lat: 31.5, lon: 130.8 },
            '宮崎県': { lat: 31.9, lon: 131.4 },
            '徳島県': { lat: 33.9, lon: 134.5 },
            '高知県': { lat: 33.5, lon: 133.5 },
            '静岡県': { lat: 34.9, lon: 138.3 },
            '神奈川県': { lat: 35.4, lon: 139.4 },
            '千葉県': { lat: 35.6, lon: 140.1 },
            '福島県': { lat: 37.4, lon: 140.4 },
            '岩手県': { lat: 39.7, lon: 141.1 },
            '青森県': { lat: 40.8, lon: 140.7 },
            '北海道太平洋沿岸東部': { lat: 42.8, lon: 144.0 },
            '北海道太平洋沿岸中部': { lat: 42.5, lon: 142.5 },
            '北海道太平洋沿岸西部': { lat: 42.0, lon: 140.5 },
            '伊豆諸島': { lat: 34.0, lon: 139.5 },
            '小笠原諸島': { lat: 27.1, lon: 142.2 },
            '和歌山県': { lat: 34.2, lon: 135.1 },
            '三重県': { lat: 34.7, lon: 136.5 },
            '愛知県': { lat: 35.0, lon: 137.0 },
            '東京都': { lat: 35.6, lon: 139.7 },
            '茨城県': { lat: 36.3, lon: 140.4 },
            '日本海沿岸': { lat: 37.5, lon: 135.0 }, // Generic, will be projected
            '東シナ海': { lat: 28.0, lon: 126.0 }, // Generic, will be projected
            '太平洋沿岸': { lat: 33.0, lon: 140.0 }, // Generic, will be projected
            '三宅島阿古': { lat: 34.08, lon: 139.52 },
            '父島二見': { lat: 27.09, lon: 142.19 },
            '三浦市三崎漁港': { lat: 35.13, lon: 139.62 },
            '伊東': { lat: 34.97, lon: 139.09 },
            '尾鷲': { lat: 34.07, lon: 136.19 },
            '那覇市泊': { lat: 26.22, lon: 127.68 },
            '徳島由岐': { lat: 33.79, lon: 134.61 },
            '土佐清水': { lat: 32.78, lon: 132.96 },
            // Missing locations from console.warn logs - manually added approximate coordinates
            '青森県太平洋沿岸': { lat: 40.8, lon: 141.5 },
            '宮城県': { lat: 38.5, lon: 141.0 },
            '千葉県九十九里・外房': { lat: 35.5, lon: 140.5 },
            '千葉県内房': { lat: 35.2, lon: 139.8 },
            '相模湾・三浦半島': { lat: 35.2, lon: 139.6 },
            '愛知県外海': { lat: 34.7, lon: 137.0 },
            '三重県南部': { lat: 34.0, lon: 136.0 },
            '北海道日本海沿岸北部': { lat: 44.5, lon: 140.5 },
            'オホーツク海沿岸': { lat: 44.0, lon: 144.0 },
            '青森県日本海沿岸': { lat: 40.8, lon: 140.0 },
            '陸奥湾': { lat: 41.0, lon: 140.9 },
            '東京湾内湾': { lat: 35.5, lon: 139.8 },
            '伊勢・三河湾': { lat: 34.8, lon: 136.8 },
            '大阪府': { lat: 34.6, lon: 135.5 },
            '兵庫県瀬戸内海沿岸': { lat: 34.7, lon: 134.8 },
            '淡路島南部': { lat: 34.2, lon: 134.8 },
            '岡山県': { lat: 34.6, lon: 133.9 },
            '愛媛県宇和海沿岸': { lat: 33.2, lon: 132.5 },
            '大分県瀬戸内海沿岸': { lat: 33.5, lon: 131.8 },
            '種子島・屋久島地方': { lat: 30.5, lon: 130.5 },
            '奄美群島・トカラ列島': { lat: 28.5, lon: 129.5 },
            '鹿児島県西部': { lat: 31.5, lon: 130.3 },
            '大東島地方': { lat: 25.8, lon: 131.2 },
            '北海道日本海沿岸南部': { lat: 43.0, lon: 140.0 },
            '秋田県': { lat: 39.7, lon: 140.0 },
            '山形県': { lat: 38.2, lon: 139.8 },
            '新潟県上中下越': { lat: 37.9, lon: 139.0 },
            '佐渡': { lat: 38.0, lon: 138.3 },
            '富山県': { lat: 36.7, lon: 137.2 },
            '石川県能登': { lat: 37.3, lon: 136.8 },
            '石川県加賀': { lat: 36.5, lon: 136.6 },
            '福井県': { lat: 36.0, lon: 136.2 },
            '京都府': { lat: 35.0, lon: 135.7 },
            '兵庫県北部': { lat: 35.5, lon: 134.7 },
            '鳥取県': { lat: 35.5, lon: 134.2 },
            '島根県出雲・石見': { lat: 35.5, lon: 132.5 },
            '隠岐': { lat: 36.2, lon: 133.0 },
            '香川県': { lat: 34.3, lon: 134.0 },
            '愛媛県瀬戸内海沿岸': { lat: 33.8, lon: 132.7 },
            '山口県日本海沿岸': { lat: 34.5, lon: 131.0 },
            '山口県瀬戸内海沿岸': { lat: 34.0, lon: 131.5 },
            '福岡県瀬戸内海沿岸': { lat: 33.8, lon: 130.8 },
            '福岡県日本海沿岸': { lat: 33.8, lon: 130.3 },
            '有明・八代海': { lat: 32.7, lon: 130.5 },
            '佐賀県北部': { lat: 33.5, lon: 129.9 },
            '長崎県西方': { lat: 32.8, lon: 129.7 },
            '壱岐・対馬': { lat: 33.8, lon: 129.5 },
            '熊本県天草灘沿岸': { lat: 32.5, lon: 130.0 },
            // Observation Stations
            '浜中町霧多布港': { lat: 43.0, lon: 145.0 },
            '十勝港': { lat: 42.7, lon: 143.4 },
            '苫小牧東港': { lat: 42.6, lon: 141.7 },
            '枝幸港': { lat: 44.9, lon: 142.5 },
            'むつ小川原港': { lat: 40.9, lon: 141.4 },
            '久慈港': { lat: 40.2, lon: 141.7 },
            '石巻港': { lat: 38.4, lon: 141.3 },
            '相馬': { lat: 37.8, lon: 140.9 },
            '大洗': { lat: 36.3, lon: 140.6 },
            '銚子': { lat: 35.7, lon: 140.8 },
            '東京晴海': { lat: 35.6, lon: 139.7 },
            '田原市赤羽根': { lat: 34.6, lon: 137.0 },
            '那智勝浦町浦神': { lat: 33.6, lon: 135.9 },
            '小松島': { lat: 34.0, lon: 134.6 },
            '宇和島': { lat: 33.2, lon: 132.5 },
            '高知': { lat: 33.5, lon: 133.5 },
            '佐伯市松浦': { lat: 32.9, lon: 131.9 },
            '日向市細島': { lat: 32.4, lon: 131.6 },
            '志布志港': { lat: 31.4, lon: 131.0 },
            '奄美市小湊': { lat: 28.3, lon: 129.5 },
            '沖縄市中城湾港': { lat: 26.3, lon: 127.8 }
        };

        // 地域ごとの境界線定義
        let currentRegionIndex = 0;
        const regionalBounds = [
            { name: '東北・北海道', bounds: L.latLngBounds([L.latLng(37, 139), L.latLng(45.5, 145.5)]) },
            { name: '関東・東海・北陸', bounds: L.latLngBounds([L.latLng(34, 135), L.latLng(38, 141)]) },
            { name: '西日本', bounds: L.latLngBounds([L.latLng(30.5, 128), L.latLng(36, 136)]) },
            { name: '沖縄・東京島しょ部', bounds: L.latLngBounds([L.latLng(24, 122), L.latLng(34.5, 142.5)]) }
        ];


        let previousTsunamiDataHash = ''; // 前回の津波データのハッシュ値

        /**
         * 指定されたURLからXMLデータを非同期で取得し、DOMParserで解析します。
         * @param {string} url - 取得するXMLのURL。
         * @returns {Promise<Document|null>} - 解析されたXMLドキュメント、またはエラーの場合はnull。
         */
        async function fetchXml(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    console.warn(`Failed to fetch XML from ${url}: HTTP status ${response.status}`);
                    return null;
                }
                const text = await response.text();
                return new DOMParser().parseFromString(text, 'application/xml');
            } catch (error) {
                console.error(`XML fetch error for ${url}:`, error);
                return null;
            }
        }

        /**
         * NHKニュースと災害情報を取得し、表示を更新します。
         */
        async function fetchNewsAndDisasterInfo() {
            newsItems = []; // ニュースアイテムをクリア

            try {
                const nhkDoc = await fetchXml('https://www.nhk.or.jp/rss/news/cat0.xml');
                if(nhkDoc) {
                    nhkDoc.querySelectorAll('item').forEach(item => {
                        newsItems.push({
                            category: 'NHKニュース',
                            title: item.querySelector('title')?.textContent || 'タイトルなし',
                            description: (item.querySelector('description')?.textContent || '').replace(/<[^>]*>?/gm, '')
                        });
                    });
                }
            } catch (e) {
                console.error("News fetch error:", e);
            }

            // ニュースアイテムがない場合のデフォルトメッセージ
            if (newsItems.length === 0) {
                newsItems.push({
                    category: '情報なし',
                    title: '現在、ニュースはありません。',
                    description: '情報を取得できませんでした。'
                });
            }

            currentItemIndex = 0;
            updateSlideshow(); // メインニュースとミニニュースを更新
            startGeneralNewsTicker(); // 一般ニュースティッカーを更新
        }

        /**
         * 天気予報データを取得し、表示を更新します。
         */
        async function fetchWeatherData() {
            fetchedWeatherData = [];
            const weatherRegions = [
                { id: '016000', name: '札幌' }, { id: '040000', name: '仙台' }, { id: '130000', name: '東京' },
                { id: '230000', name: '名古屋' }, { id: '270000', name: '大阪' }, { id: '340000', name: '広島' },
                { id: '400000', name: '博多' }, { id: '471000', name: '那覇' }
            ];
            for (const region of weatherRegions) {
                try {
                    const response = await fetch(`https://www.jma.go.jp/bosai/forecast/data/forecast/${region.id}.json`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    const latestForecast = data[0];
                    if (!latestForecast) continue;

                    let weatherText = '', temperature = '';
                    const weatherSeries = latestForecast.timeSeries.find(ts => ts.areas[0]?.weathers);
                    if (weatherSeries && weatherSeries.areas.length > 0) {
                        weatherText = weatherSeries.areas[0].weathers[0]?.replace(/　所により.*|　時々.*|昼前.*|朝.*|夜.*|明日.*|、.*|を伴う/g, '').replace(/[、。]/g, '').trim() || '';
                    }
                    const tempSeries = latestForecast.timeSeries.find(ts => ts.areas[0]?.temps);
                    if (tempSeries && tempSeries.areas.length > 0) {
                        const targetAreaTemp = tempSeries.areas.find(area => area.area.name === region.name);
                        if (targetAreaTemp && targetAreaTemp.temps.length > 0) {
                            temperature = `${targetAreaTemp.temps[0]}℃`;
                        } else {
                            const dailyTempSeries = latestForecast.timeSeries.find(ts => ts.areas[0]?.tempsMax || ts.areas[0]?.tempsMin);
                            if (dailyTempSeries) {
                                const dailyTargetArea = dailyTempSeries.areas.find(area => area.area.name === region.name);
                                if(dailyTargetArea) {
                                    const maxTemp = dailyTargetArea.tempsMax && dailyTargetArea.tempsMax[0] ? dailyTargetArea.tempsMax[0] : '';
                                    const minTemp = dailyTargetArea.tempsMin && dailyTargetArea.tempsMin[0] ? dailyTargetArea.tempsMin[0] : '';
                                    if(maxTemp && minTemp) temperature = `${maxTemp}℃ (${minTemp}℃)`;
                                    else if (maxTemp) temperature = `${maxTemp}℃`;
                                    else if (minTemp) temperature = `${minTemp}℃`;
                                }
                            }
                        }
                    }
                    if (temperature !== '' || weatherText !== '') {
                        fetchedWeatherData.push({ city: region.name, temp: temperature, condition: weatherText });
                    }
                } catch (error) { console.error(`天気予報の取得エラー (${region.name}):`, error); }
            }
            currentWeatherIndex = 0;
            updateWeather();
        }

        /**
         * 津波データを取得し、表示を更新します。
         */
        async function fetchTsunamiData() {
            try {
                const feedDoc = await fetchXml('https://www.data.jma.go.jp/developer/xml/feed/eqvol.xml');
                if (!feedDoc) {
                    // 津波情報が取得できない場合もティッカーを更新
                    tickerItems = [{ category: 'ティッカー情報', title: '現在、緊急地震速報や津波情報はありません。' }];
                    startTicker();
                    clearTsunamiMap(); // 地図をクリア
                    // stopMapRegionCycling() はこの関数の最後に制御されるため、ここでは呼ばない
                    return;
                }

                allTsunamiForecasts = []; // 前回のデータをクリア
                allTsunamiObservations = []; // 前回のデータをクリア
                let foundTsunamiInfo = false; // 津波情報が見つかったかどうかのフラグ
                let reportTitle = "";
                let highestWarningLevel = 0;
                let hasObservation = false;
                let currentTsunamiHeadline = ''; // 現在の津波情報の見出しを保持

                // 最新の津波関連エントリを特定
                let latestTsunamiEntry = null;
                let latestUpdatedTime = new Date(0); // エポックタイムで初期化

                feedDoc.querySelectorAll('entry').forEach(entry => {
                    const title = entry.querySelector('title')?.textContent || '';
                    if (title.includes('津波')) {
                        const updatedTimeStr = entry.querySelector('updated')?.textContent;
                        if (updatedTimeStr) {
                            const updatedTime = new Date(updatedTimeStr);
                            if (updatedTime > latestUpdatedTime) {
                                latestUpdatedTime = updatedTime;
                                latestTsunamiEntry = entry;
                            }
                        }
                    }
                });

                if (latestTsunamiEntry) {
                    const link = latestTsunamiEntry.querySelector('link[type="application/xml"]')?.getAttribute('href');
                    
                    // --- デバッグ用ログ ---
                    console.log("--- 津波データ取得ログ ---");
                    console.log("最新の津波エントリが見つかったか:", !!latestTsunamiEntry);
                    // linkが定義されているか確認
                    if (link) {
                        console.log("最新の津波エントリのリンク:", link); 
                    } else {
                        console.log("最新の津波エントリのリンクが見つかりませんでした。");
                    }
                    // --- デバッグ用ログ終了 ---

                    if (link) {
                        const detailDoc = await fetchXml(link);
                        if (detailDoc) {
                            currentTsunamiHeadline = detailDoc.querySelector('Head Headline Text')?.textContent.trim() || '';
                            
                            const headTitle = detailDoc.querySelector('Head Title')?.textContent || '';
                            if(headTitle.includes("津波観測")) {
                                hasObservation = true;
                                reportTitle = "津波観測に関する情報";
                            } else if (!reportTitle) {
                                reportTitle = "津波情報";
                            }

                            // 予報の解析
                            detailDoc.querySelectorAll('Body Tsunami Forecast Item').forEach(item => {
                                const areaName = item.querySelector('Area Name')?.textContent || '';
                                const kindName = item.querySelector('Category Kind Name')?.textContent || '';
                                console.log("Forecast Kind Name:", kindName); // デバッグ用ログ
                                if (kindName.includes('大津波警報')) highestWarningLevel = 3;
                                else if (kindName.includes('津波警報')) highestWarningLevel = Math.max(highestWarningLevel, 2);
                                else if (kindName.includes('津波注意報')) highestWarningLevel = Math.max(highestWarningLevel, 1);
                                
                                let arrivalTime = '-';
                                const arrivalTimeEl = item.querySelector('FirstHeight ArrivalTime');
                                if (arrivalTimeEl?.textContent) { 
                                    try { 
                                        const d = new Date(arrivalTimeEl.textContent); 
                                        arrivalTime = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; 
                                    } catch(e){ console.warn("Invalid arrival time date format in forecast:", arrivalTimeEl.textContent, e); }
                                }
                                
                                const maxHeightEl = item.querySelector('MaxHeight');
                                let maxHeightText = '-';
                                if (maxHeightEl) {
                                    const tsunamiHeightEl = maxHeightEl.getElementsByTagNameNS('http://xml.kishou.go.jp/jmaxml1/elementBasis1/', 'TsunamiHeight')[0];
                                    if (tsunamiHeightEl) {
                                        if (tsunamiHeightEl.textContent) {
                                            maxHeightText = tsunamiHeightEl.textContent + 'm';
                                        } else if (tsunamiHeightEl.getAttribute('description')) {
                                            maxHeightText = tsunamiHeightEl.getAttribute('description');
                                        }
                                    }
                                }
                                if (areaName && kindName) {
                                    allTsunamiForecasts.push({ areaName, kindName, maxHeight: maxHeightText, arrivalTime });
                                }
                            });

                            // 観測の解析 (堅牢性を向上)
                            detailDoc.querySelectorAll('Body Tsunami Observation Item').forEach(item => {
                                const stationName = item.querySelector('Station Name')?.textContent || '';
                                
                                let arrivalTime = '-';
                                const firstHeightEl = item.querySelector('FirstHeight');
                                if (firstHeightEl) {
                                    const arrivalTimeNode = firstHeightEl.querySelector('ArrivalTime');
                                    const conditionNode = firstHeightEl.querySelector('Condition');
                                    if (arrivalTimeNode?.textContent) {
                                        try { 
                                            const d = new Date(arrivalTimeNode.textContent); 
                                            arrivalTime = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; 
                                        } catch(e){ console.warn("Invalid arrival time date format in observation:", arrivalTimeNode.textContent, e); }
                                    } else if (conditionNode?.textContent) {
                                        arrivalTime = conditionNode.textContent;
                                    }
                                }

                                let maxHeightText = '-';
                                const maxHeightEl = item.querySelector('MaxHeight');
                                if(maxHeightEl) {
                                    const tsunamiHeightEl = maxHeightEl.getElementsByTagNameNS('http://xml.kishou.go.jp/jmaxml1/elementBasis1/', 'TsunamiHeight')[0];
                                    const conditionEl = maxHeightEl.querySelector('Condition');
                                    
                                    if (tsunamiHeightEl) {
                                        if (tsunamiHeightEl.textContent) {
                                            maxHeightText = tsunamiHeightEl.textContent + 'm';
                                        } else if (tsunamiHeightEl.getAttribute('description')) {
                                            maxHeightText = tsunamiHeightEl.getAttribute('description');
                                        }
                                    } else if (conditionEl?.textContent) {
                                        maxHeightText = conditionEl.textContent;
                                    }
                                }
                                
                                if (stationName && (arrivalTime !== '-' || maxHeightText !== '-')) { // 有効なデータがある場合のみ追加
                                    allTsunamiObservations.push({ stationName, arrivalTime, maxHeight: maxHeightText });
                                }
                            });
                            // 予報または観測データが見つかったらfoundTsunamiInfoをtrueにする
                            if (allTsunamiForecasts.length > 0 || allTsunamiObservations.length > 0) {
                                foundTsunamiInfo = true;
                            }
                        }
                    }
                }

                // --- デバッグ用ログ ---
                console.log("レポートタイトル:", reportTitle);
                console.log("津波予報データ:", allTsunamiForecasts);
                console.log("津波観測データ:", allTsunamiObservations);
                console.log("判定された最高警報レベル (highestWarningLevel):", highestWarningLevel);
                console.log("津波情報が見つかったか (foundTsunamiInfo):", foundTsunamiInfo);
                // --- 津波データ取得ログ終了 ---

                // ティッカーアイテムの更新
                tickerItems = []; // まずクリア
                if (foundTsunamiInfo) {
                    let tickerMessage = currentTsunamiHeadline.replace(/\n/g, ' ');
                    if (!tickerMessage) { // 見出しが空の場合のフォールバック
                        if (highestWarningLevel === 3) tickerMessage = '大津波警報が発表されています。';
                        else if (highestWarningLevel === 2) tickerMessage = '津波警報が発表されています。';
                        else if (highestWarningLevel === 1) tickerMessage = '津波注意報が発表されています。';
                        else if (allTsunamiObservations.length > 0) tickerMessage = '津波観測情報があります。';
                        else tickerMessage = '津波関連情報があります。'; // 一般的なフォールバック
                    }

                    if (highestWarningLevel === 3) {
                        tickerMessage = '【大津波警報】 ' + tickerMessage;
                    } else if (highestWarningLevel === 2) {
                        tickerMessage = '【津波警報】 ' + tickerMessage;
                    } else if (highestWarningLevel === 1) {
                        tickerMessage = '【津波注意報】 ' + tickerMessage;
                    } else {
                        tickerMessage = '【津波情報】 ' + tickerMessage; // 観測情報などの場合
                    }
                    tickerItems.push({ category: '津波情報', title: tickerMessage });
                } else {
                    tickerItems.push({ category: 'ティッカー情報', title: '現在、緊急地震速報や津波情報はありません。' });
                }
                startTicker(); // ティッカーを更新

                // 津波情報の表示切り替えロジック
                dom.body.className = ''; // 既存のクラスをリセット
                if (highestWarningLevel === 3) dom.body.classList.add('tsunami-major-warning');
                else if (highestWarningLevel === 2) dom.body.classList.add('tsunami-warning');
                else if (highestWarningLevel === 1) dom.body.classList.add('tsunami-advisory');

                if (foundTsunamiInfo) { // 津波情報が見つかった場合
                    if (!isTsunamiActive) { dom.bgmAudio.pause(); isTsunamiActive = true; }
                    dom.body.classList.add('tsunami-layout-active');
                    dom.body.classList.add('mini-news-active'); /* mini-news-activeクラスを追加 */
                    if(hasObservation) dom.body.classList.add('observation-active');

                    dom.tsunamiEvacuateWarning.classList.toggle('active', highestWarningLevel > 1);
                    dom.tsunamiInfoHeader.textContent = reportTitle;
                    dom.tsunamiInfoContainer.classList.add('active');
                    dom.newsBox.classList.remove('active');
                    dom.generalNewsTicker.style.display = 'none';
                    dom.miniNewsDisplay.classList.add('active');
                    dom.tsunamiMapContainer.classList.add('active'); // 地図を表示
                    stopMapRegionCycling(); // 地域表示の自動切り替えを停止
                    dom.mapRegionDisplay.style.display = 'none'; // 地域名表示を非表示

                    dom.tsunamiForecastContainer.classList.toggle('active', allTsunamiForecasts.length > 0);
                    dom.tsunamiObservationContainer.classList.toggle('active', allTsunamiObservations.length > 0);

                    currentTsunamiForecastPage = 0;
                    currentTsunamiObservationPage = 0;

                    displayTsunamiForecastPage();
                    setupTsunamiForecastPagination();

                    displayTsunamiObservationPage();
                    setupTsunamiObservationPagination();

                    // 地図の描画
                    updateTsunamiMap(allTsunamiForecasts, allTsunamiObservations, highestWarningLevel);

                } else { // 津波情報が見つからなかった場合
                    if (isTsunamiActive) { dom.bgmAudio.play().catch(e=>{}); isTsunamiActive = false; }
                    dom.body.classList.remove('tsunami-layout-active', 'observation-active', 'tsunami-advisory', 'tsunami-warning', 'tsunami-major-warning');
                    dom.body.classList.remove('mini-news-active'); /* mini-news-activeクラスを削除 */
                    dom.tsunamiEvacuateWarning.classList.remove('active');
                    dom.tsunamiInfoContainer.classList.remove('active');
                    dom.newsBox.classList.add('active');
                    dom.generalNewsTicker.style.display = 'flex';
                    dom.miniNewsDisplay.classList.remove('active');
                    dom.tsunamiMapContainer.classList.remove('active'); // 地図を非表示にする（CSSでdisplay:noneが適用される）
                    clearTsunamiMap(); // 地図をクリア
                    startMapRegionCycling(); // 地域表示の自動切り替えを開始
                    // dom.mapRegionDisplay.style.display は startMapRegionCycling() 内で制御される
                }
            } catch (error) {
                console.error("Tsunami data processing error:", error);
                // エラー発生時もデフォルト状態に戻す
                if (isTsunamiActive) { dom.bgmAudio.play().catch(e=>{}); isTsunamiActive = false; }
                dom.body.classList.remove('tsunami-layout-active', 'observation-active', 'tsunami-advisory', 'tsunami-warning', 'tsunami-major-warning');
                dom.body.classList.remove('mini-news-active');
                dom.tsunamiEvacuateWarning.classList.remove('active');
                dom.tsunamiInfoContainer.classList.remove('active');
                dom.newsBox.classList.add('active');
                dom.generalNewsTicker.style.display = 'flex';
                dom.miniNewsDisplay.classList.remove('active');
                dom.tsunamiMapContainer.classList.remove('active'); // 地図を非表示にする
                clearTsunamiMap(); // 地図をクリア
                startMapRegionCycling(); // 地域表示の自動切り替えを開始
                // dom.mapRegionDisplay.style.display は startMapRegionCycling() 内で制御される

                if (tsunamiForecastPageInterval) clearInterval(tsunamiForecastPageInterval);
                if (tsunamiObservationPageInterval) clearInterval(tsunamiObservationPageInterval);
                
                // エラー発生時もティッカーをデフォルトメッセージで更新
                tickerItems = [{ category: 'ティッカー情報', title: '現在、緊急地震速報や津波情報はありません。' }];
                startTicker();
            }
        }

        /**
         * 津波予報データをページごとに表示する関数
         */
        function displayTsunamiForecastPage() {
            const startIndex = currentTsunamiForecastPage * ITEMS_PER_PAGE;
            const endIndex = startIndex + ITEMS_PER_PAGE;
            const pageItems = allTsunamiForecasts.slice(startIndex, endIndex);
            dom.tsunamiForecastBody.innerHTML = pageItems.map(info => `<tr><td>${info.areaName}</td><td class="${getKindClassName(info.kindName)}">${info.kindName}</td><td>${info.arrivalTime}</td><td>${info.maxHeight}</td></tr>`).join('');
            
            const dots = dom.tsunamiForecastPagination.querySelectorAll('.dot');
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index === currentTsunamiForecastPage);
            });
        }

        /**
         * 津波予報データ用のページネーションを設定する関数
         */
        function setupTsunamiForecastPagination() {
            const pageCount = Math.ceil(allTsunamiForecasts.length / ITEMS_PER_PAGE);
            dom.tsunamiForecastPagination.innerHTML = '';
            if (pageCount > 1) {
                for (let i = 0; i < pageCount; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    dom.tsunamiForecastPagination.appendChild(dot);
                }
                if (tsunamiForecastPageInterval) clearInterval(tsunamiForecastPageInterval);
                tsunamiForecastPageInterval = setInterval(() => {
                    currentTsunamiForecastPage = (currentTsunamiForecastPage + 1) % pageCount;
                    displayTsunamiForecastPage();
                }, 8000);
            } else {
                if (tsunamiForecastPageInterval) clearInterval(tsunamiForecastPageInterval);
            }
            displayTsunamiForecastPage();
        }

        /**
         * 津波観測データをページごとに表示する関数
         */
        function displayTsunamiObservationPage() {
            const startIndex = currentTsunamiObservationPage * ITEMS_PER_PAGE;
            const endIndex = startIndex + ITEMS_PER_PAGE;
            const pageItems = allTsunamiObservations.slice(startIndex, endIndex);
            dom.tsunamiObservationBody.innerHTML = pageItems.map(obs => `<tr><td>${obs.stationName}</td><td>${obs.arrivalTime}</td><td class="${getConditionClass(obs.maxHeight)}">${obs.maxHeight}</td></tr>`).join('');
            
            const dots = dom.tsunamiObservationPagination.querySelectorAll('.dot');
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index === currentTsunamiObservationPage);
            });
        }

        /**
         * 津波観測データ用のページネーションを設定する関数
         */
        function setupTsunamiObservationPagination() {
            const pageCount = Math.ceil(allTsunamiObservations.length / ITEMS_PER_PAGE);
            dom.tsunamiObservationPagination.innerHTML = '';
            if (pageCount > 1) {
                for (let i = 0; i < pageCount; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    dom.tsunamiObservationPagination.appendChild(dot);
                }
                if (tsunamiObservationPageInterval) clearInterval(tsunamiObservationPageInterval);
                tsunamiObservationPageInterval = setInterval(() => {
                    currentTsunamiObservationPage = (currentTsunamiObservationPage + 1) % pageCount;
                    displayTsunamiObservationPage();
                }, 8000);
            } else {
                if (tsunamiObservationPageInterval) clearInterval(tsunamiObservationPageInterval);
            }
            displayTsunamiObservationPage();
        }

        /**
         * 現在時刻を更新し、表示します。
         */
        function updateClock() { 
            const now = new Date(); 
            dom.currentClock.innerHTML = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}<span class="clock-seconds">:${String(now.getSeconds()).padStart(2, '0')}</span>`; 
        }

        /**
         * 天気予報を更新し、表示します。
         */
        function updateWeather() { 
            if (fetchedWeatherData.length === 0) return; 
            const weather = fetchedWeatherData[currentWeatherIndex]; 
            dom.weatherForecast.textContent = `${weather.city} ${weather.temp} ${weather.condition}`; 
            currentWeatherIndex = (currentWeatherIndex + 1) % fetchedWeatherData.length; 
        }
        
        /**
         * メインニュースとミニニュースのスライドショーを更新します。
         */
        function updateSlideshow() {
            if (newsItems.length === 0) return;
            currentItemIndex = (currentItemIndex + 1) % newsItems.length;
            const item = newsItems[currentItemIndex];
            dom.newsCategory.textContent = item.category;
            dom.newsTitle.textContent = item.title;
            dom.newsDescriptionMain.textContent = item.description;

            // ミニニュースディスプレイも更新
            updateMiniNewsDisplay(item);
        }

        /**
         * ミニニュースディスプレイを更新する関数
         * @param {object} item - 表示するニュースアイテム。
         */
        function updateMiniNewsDisplay(item) {
            dom.miniNewsCategory.textContent = item.category;
            dom.miniNewsTitle.textContent = item.title;
            dom.miniNewsDescription.textContent = item.description;
        }

        /**
         * 上部の一般ニュースティッカーを開始または更新します。
         */
        function startGeneralNewsTicker() {
            clearInterval(generalNewsTickerAnimationInterval);

            if (newsItems.length === 0) {
                dom.generalNewsContent.textContent = "現在、ニュースはありません。";
                dom.generalNewsContent.style.animation = 'none';
                dom.generalNewsContent.style.transform = 'translateX(0)';
                return;
            }

            const fullNewsText = newsItems.map(item => `【${item.category}】${item.title}`).join('　　　　');
            dom.generalNewsContent.textContent = fullNewsText;

            requestAnimationFrame(() => {
                setTimeout(() => {
                    dom.generalNewsContent.style.animation = 'none';
                    dom.generalNewsContent.offsetHeight; // 強制的にリフロー

                    const textWidth = dom.generalNewsContent.scrollWidth;
                    const containerWidth = dom.generalNewsTicker.clientWidth;

                    if (textWidth > containerWidth && containerWidth > 0) {
                        const duration = (textWidth / 100) * 0.8;
                        dom.generalNewsContent.style.animation = `generalNewsScroll ${duration}s linear infinite`;
                        dom.generalNewsContent.style.animationPlayState = 'running';
                    } else {
                        dom.generalNewsContent.style.animation = 'none';
                        dom.generalNewsContent.style.transform = 'translateX(0)';
                    }
                }, 10);
            });
        }

        /**
         * 下部の災害情報ティッカーを開始または更新します。
         */
        function startTicker() {
            clearInterval(tickerAnimationInterval);
            
            let fullTickerText = tickerItems.map(item => `【${item.category}】 ${item.title}`).join('　　　　');
            dom.tickerContent.textContent = fullTickerText;

            // アニメーションをリセットして再開
            dom.tickerContent.style.animation = 'none';
            dom.tickerContent.offsetHeight; // 強制的にリフロー
            dom.tickerContent.style.animation = null; // アニメーションプロパティをリセット

            const textWidth = dom.tickerContent.scrollWidth;
            const containerWidth = dom.tickerContent.parentElement.clientWidth;

            if (textWidth > containerWidth && containerWidth > 0) {
                const duration = (textWidth / 100) * 0.5;
                dom.tickerContent.style.animation = `tickerScroll ${duration}s linear infinite`;
                dom.tickerContent.style.animationPlayState = 'running';
            } else {
                dom.tickerContent.style.animation = 'none';
                dom.tickerContent.style.transform = 'translateX(0)';
            }
        }
        
        /**
         * 津波の種類に応じたCSSクラス名を返します。
         * @param {string} kindName - 津波の種類名。
         * @returns {string} - 対応するCSSクラス名。
         */
        function getKindClassName(kindName) { 
            if (kindName.includes('大津波警報')) return 'kind-major-warning'; 
            if (kindName.includes('津波警報')) return 'kind-warning'; 
            if (kindName.includes('津波注意報')) return 'kind-advisory'; 
            return ''; 
        }

        /**
         * 津波観測の状況に応じたCSSクラス名を返します。
         * @param {string} condition - 津波の観測状況。
         * @returns {string} - 対応するCSSクラス名。
         */
        function getConditionClass(condition) { 
            if(condition.includes('高い')) return 'condition-high'; 
            if(condition.includes('上昇中')) return 'condition-rise'; 
            return ''; 
        }

        /**
         * 津波の高さに基づいてピンの色を決定する関数
         * @param {string} heightText - 津波の高さを示すテキスト（例: "0.2m", "高い", "不明"）。
         * @returns {string} - 対応する色コード。
         */
        function getTsunamiHeightColor(heightText) {
            console.log(`getTsunamiHeightColor received: "${heightText}"`);
            if (!heightText) {
                console.log(`Returning #808080 for empty heightText.`);
                return '#808080'; // Default grey for undefined/null
            }

            // 数値と単位を抽出
            const match = heightText.match(/(\d+\.?\d*)\s*m/);
            if (match) {
                const height = parseFloat(match[1]);
                console.log(`Parsed height: ${height}`);
                if (height < 0.2) { console.log(`Returning #00BFFF for < 0.2m`); return '#00BFFF'; } // 0.2m未満: Light Blue
                if (height < 0.5) { console.log(`Returning #32CD32 for < 0.5m`); return '#32CD32'; } // 0.2m〜0.5m未満: Green
                if (height < 1.0) { console.log(`Returning #FFFF00 for < 1.0m`); return '#FFFF00'; } // 0.5m〜1.0m未満: Yellow
                if (height < 3.0) { console.log(`Returning #FF8C00 for < 3.0m`); return '#FF8C00'; } // 1.0m〜3.0m未満: Orange
                console.log(`Returning #FF0000 for >= 3.0m`);
                return '#FF0000'; // 3.0m以上: Red
            }

            // 数値でない場合や特定のキーワード
            if (heightText.includes('高い') || heightText.includes('巨大')) { console.log(`Returning #8B008B for "高い" or "巨大"`); return '#8B008B'; } // 「高い」「巨大」: Dark Magenta/Purple
            if (heightText.includes('不明') || heightText.includes('観測中') || heightText.includes('解析中') || heightText === '-') { console.log(`Returning #808080 for unknown/observing`); return '#808080'; } // 不明・観測中など: Grey

            console.log(`Returning #808080 as fallback`);
            return '#808080'; // Fallback to grey
        }

        /**
         * 津波情報を地図上にLeafletマーカーとしてプロットし、スライドショーを管理する関数
         * @param {Array} forecasts - 津波予報データの配列 (この関数では使用しない)
         * @param {Array} observations - 津波観測データの配列
         * @param {number} highestLevel - 最高警報レベル (1:注意報, 2:警報, 3:大津波警報) (この関数では使用しない)
         */
        function updateTsunamiMap(forecasts, observations, highestLevel) {
            const currentTsunamiData = JSON.stringify({ forecasts, observations, highestLevel });
            if (previousTsunamiDataHash === currentTsunamiData) {
                // データに変更がない場合はマーカーを再描画しない
                // ただし、スライドショーは継続させるため、ここではreturnしない
            }
            previousTsunamiDataHash = currentTsunamiData;

            // 既存のマーカーをすべてクリア
            currentTsunamiMarkers.clearLayers();

            const allPoints = [];
            // 予報データは地図マーカーには表示しないため、以下のループを削除
            /*
            forecasts.forEach(item => {
                const loc = mapLocations[item.areaName];
                if (loc) {
                    const color = getTsunamiHeightColor(item.maxHeight); // 津波の高さに基づいて色を決定
                    allPoints.push({
                        lat: loc.lat, lon: loc.lon, color: color,
                        text: `${item.areaName}: ${item.maxHeight} (${item.arrivalTime})`,
                        id: `forecast-${item.areaName}` // ユニークID
                    });
                } else {
                    console.warn(`予報地域の緯度経度情報が見つかりません: ${item.areaName}`);
                }
            });
            */
            observations.forEach(item => {
                const loc = mapLocations[item.stationName];
                if (loc) {
                    const color = getTsunamiHeightColor(item.maxHeight); // 津波の高さに基づいて色を決定
                    allPoints.push({
                        lat: loc.lat, lon: loc.lon, color: color,
                        text: `${item.stationName}: ${item.maxHeight} (${item.arrivalTime})`,
                        id: `observation-${item.stationName}` // ユニークID
                    });
                } else {
                    console.warn(`観測地点の緯度経度情報が見つかりません: ${item.stationName}`);
                }
            });
            console.log("地図に追加する合計ポイント数:", allPoints.length, allPoints);

            // マーカーを地図に追加
            allPoints.forEach(point => {
                const marker = L.circleMarker([point.lat, point.lon], {
                    radius: 6, // マーカーの半径
                    fillColor: point.color,
                    color: 'white', // 枠線の色
                    weight: 1, // 枠線の太さ
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(currentTsunamiMarkers); // レイヤーグループに追加

                // ツールチップは表示しないため、以下の行を削除またはコメントアウト
                /*
                marker.bindTooltip(point.text, {
                    permanent: true,    // 常に表示
                    direction: 'right', // マーカーの右に表示
                    offset: [10, 0],    // マーカーからのオフセット
                    className: 'map-tooltip' // カスタムCSSクラス
                });
                */
            });

            currentTsunamiMarkers.addTo(map); // レイヤーグループをマップに追加

            // スライドショーはLeafletマーカーのツールチップ表示に置き換えられたため、
            // 個別のマーカーテキストスライドショーは不要になります。
            // 必要であれば、特定のマーカーをハイライトするロジックを追加できます。
        }

        /**
         * 津波地図をクリアする関数
         * LeafletマップからすべてのGeoJSONレイヤーとマーカーを削除します。
         */
        function clearTsunamiMap() {
            currentTsunamiMarkers.clearLayers(); // すべての津波マーカーをクリア
            previousTsunamiDataHash = ''; // ハッシュをリセット
        }

        /**
         * 地図の地域表示を更新し、対応する地域にズームする関数
         */
        function updateMapRegionDisplay() {
            if (!map) return; // 地図が初期化されていない場合は何もしない

            const region = regionalBounds[currentRegionIndex];
            map.fitBounds(region.bounds, { padding: [20, 20] }); // 地域にズームし、パディングを追加
            dom.mapRegionDisplay.textContent = region.name; // 地域名を表示
        }

        /**
         * 地図の地域表示の自動切り替えを開始する関数
         */
        function startMapRegionCycling() {
            if (mapRegionCyclingInterval) clearInterval(mapRegionCyclingInterval); // 既存のインターバルをクリア

            // 地図コンテナを明示的に表示する (地域表示がアクティブな間は常に表示)
            dom.tsunamiMapContainer.style.display = 'flex'; 
            map.invalidateSize(); // サイズ変更があった場合は再計算

            updateMapRegionDisplay(); // 初回表示

            mapRegionCyclingInterval = setInterval(() => {
                currentRegionIndex = (currentRegionIndex + 1) % regionalBounds.length;
                updateMapRegionDisplay();
            }, 10000); // 10秒ごとに切り替え
            dom.mapRegionDisplay.style.display = 'block'; // 地域名表示を表示
        }

        /**
         * 地図の地域表示の自動切り替えを停止する関数
         */
        function stopMapRegionCycling() {
            if (mapRegionCyclingInterval) {
                clearInterval(mapRegionCyclingInterval);
                mapRegionCyclingInterval = null;
            }
            dom.mapRegionDisplay.style.display = 'none'; // 地域名表示を非表示
            // ここで dom.tsunamiMapContainer.style.display = 'none'; は削除。
            // 地図コンテナの表示/非表示は fetchTsunamiData() 内の classList.add/remove('active') で制御されるべき
        }


        // ページロード時の初期化処理
        window.onload = async () => {
            dom.loadingOverlay.style.display = 'flex'; // Show loading overlay at the very beginning

            // Leafletマップの初期化前にコンテナを表示状態にする
            // これにより、Leafletが初期サイズを正しく計算できるようになります。
            dom.tsunamiMapContainer.style.display = 'block';

            // Leafletマップの初期化
            map = L.map(dom.tsunamiMapDiv, {
                zoomControl: false, // ズームコントロールを非表示にする
                minZoom: 4 // 日本全体が表示されるくらいの最小ズームレベルを設定
            }).setView([36.2048, 138.2529], 5); // 日本の中心にズームレベル5で設定

            // 日本全体をカバーする境界線を設定 (緯度: 北46度, 南20度; 経度: 西122度, 東148度)
            const southWest = L.latLng(20, 122);
            const northEast = L.latLng(46, 148);
            const bounds = L.latLngBounds(southWest, northEast);

            map.setMaxBounds(bounds); // 地図の最大表示範囲を設定
            map.fitBounds(bounds, { padding: [20, 20] }); // 日本全体が収まるように地図を調整し、20pxのパディングを追加
            map.invalidateSize(); // 地図のサイズを再計算させる

            // OpenStreetMapタイルレイヤーの追加
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 10 // 最大ズームレベルを設定 (必要に応じて調整)
            }).addTo(map);

            // すべての初期データ取得を並行して実行し、完了を待つ
            await Promise.all([
                fetchTsunamiData(), // 津波データ取得 (この中で地図の表示/非表示と地域表示の開始/停止が制御されます)
                fetchNewsAndDisasterInfo(), // ニュースと災害情報を取得
                fetchWeatherData() // 天気予報を取得
            ]);

            // すべての初期データ取得が完了したら、ローディングオーバーレイを非表示にする
            dom.loadingOverlay.style.display = 'none';

            // fetchTsunamiDataが完了し、isTsunamiActiveがfalseであれば、ここで地域表示を開始
            if (!isTsunamiActive) {
                startMapRegionCycling();
            } else {
                // 津波情報がアクティブな場合は、地図コンテナを表示状態に保つ
                dom.tsunamiMapContainer.classList.add('active');
            }

            // 定期更新のインターバルを開始
            setInterval(updateClock, 1000); // 時計の更新間隔
            setInterval(updateSlideshow, 15000); // メインニュースのスライドショー間隔
            setInterval(updateWeather, 10000); // 天気予報の更新間隔
            setInterval(fetchTsunamiData, 30000); // 津波データの取得間隔 (30秒ごと)
            setInterval(fetchNewsAndDisasterInfo, 30 * 60 * 1000); // 全ニュース/災害情報の再取得間隔 (30分ごと)
            dom.bgmAudio.play().catch(e => console.warn("BGM Autoplay Blocked"));
        };
    </script>
</body>
</html>
